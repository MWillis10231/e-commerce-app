import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

const initialState = {
  data: {
    id: null,
    items: []
  },
  status: "idle",
  error: null,
  totalItems: 0,
  totalPrice: 0,
};

// async Thunk for getting cart
export const getCart = createAsyncThunk("/cart/fetchCart", async () => {
  const response = await fetch("/api/cart/", {
    credentials: "include",
  });
  //console.log(response);
  if (response.ok) {
    const json = await response.json();
    return json;
  } else {
    return Promise.reject(
      new Error(`${response.status} - ${response.statusText}`)
    );
  }
});

export const cartSlice = createSlice({
  name: "cart",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    deleteCart(state, action) {
      state.data = {
        id: null,
        items: []
      }
      state.status = "idle";
      state.error = null;
    },
    updateCart(state, action) {
        const { id, quantity } = action.payload;
        // find the right item, then update its contents
        let item = state.data.items.find((item) => item.id === id)
        item.quantity = parseInt(quantity);
        item.totalPrice = (parseInt(item.quantity) * parseInt(item.unitPrice)).toFixed(2);
    },
    addCartItem(state, action) {
      const { id, quantity } = action.payload;
      let item
      if (state.data.items.length) {
        item = state.data.items.find((item) => item.id === id)
      }
      //if it exists already, update quantity, otherwise push it
      if (item) {
        item.quantity = parseInt(item.quantity) + parseInt(quantity);
        item.totalPrice = parseInt(item.quantity) * parseInt(item.unitPrice);
      } else {
        state.data.items.push(action.payload)
      }
    },
    removeCartItem(state, action) {
        const { id } = action.payload;
        state.data.items = state.data.items.filter((item) => item.id !== id)
    },
    calculateCartTotals (state, action) {
        let price = 0
        let quantity = 0
        state.data.items.forEach(element => {
          price = price + element.totalPrice
          quantity = quantity + parseInt(element.quantity)
        })
        state.totalItems = quantity;
        state.totalPrice = price.toFixed(2);
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getCart.pending, (state) => {
        state.status = "loading";
        state.error = null;
      })
      .addCase(getCart.fulfilled, (state, action) => {
        state.status = "success";
        state.data = action.payload;
        state.error = null;
      })
      .addCase(getCart.rejected, (state, action) => {
        state.status = "failed";
        state.error = action.error.message;
      });
  },
});

export const { deleteCart, updateCart, addCartItem, removeCartItem, calculateCartTotals } = cartSlice.actions;

export default cartSlice.reducer;

export const selectCartStatus = (state) => state.cart.status;
export const selectCartError = (state) => state.cart.error;
export const selectCartContents = (state) => state.cart.data;
export const selectCartContentNumber = (state) => {
    if (state.cart.data.items) {
        return state.cart.data.items.length;
    } else {
        return 0
    }
}

export const selectTotalItems = (state) => state.cart.totalItems;
export const selectTotalPrice = (state) => state.cart.totalPrice;

export const selectSingleCartItem = (state, productId) =>
  state.cart.data.items.find((element) => element.id === productId);
